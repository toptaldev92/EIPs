## Preamble

```
EIP: <to be assigned>
Title: ERC-721 Distinguishable Assets Registry
Author: William Entriken <github.com@phor.net>, Dieter Shirley <dete@axiomzen.co>, Jacob Evans <jacob@dekz.net>, Nastassia Sachs <nastassia.sachs@protonmail.com>
Type: Standard
Category ERC
Status: Draft
Created: 2018-01-24
Requires: ERC-165
```

## Simple Summary

A standard interface for any Distinguishable Assets Registry ("DAR"). A DAR tracks ownership of a set of assets that are mutually distinguishable. These assets may also be known as non-fungible tokens.

## Abstract

Tracking the ownership of physical or digital distinguishable assets on a blockchain has a broad range of applications. We consider use cases of assets being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers ("operators").

The kind of assets to which a DAR expresses ownership are an implementation detail. While writing this standard we considered a diverse univerise of assets, and we know you will dream up many more:

- Physical property — houses, unique artwork
- Virtual collectables — unique pictures of kittens, collectable cards
- "Negative value" assets — loans, burdens and other responsibilities

In general, all houses are distinct and no two kittens are alike. Therefore you must track each asset separately; it is insufficient to simply count the assets you own.

## Motivation

A standard interface allows wallet/broker/auction applications to work with any DAR on Ethereum. We provide for simple DAR contracts as well as contracts that track an *arbitrarily large* number of assets.  Additional applications are discussed below.

This standard is inspired by [the ERC-20 token standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) and builds on two years of experience since EIP-20 was created. EIP-20 is insufficient for tracking asset ownership because each asset is distinct (non-fungible) whereas each of a quantity of tokens is identical (fungible).

Differences between this standard and EIP-20 are examined below.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

The **baseline specification** is REQUIRED for all ERC-721 implementations (see "caveats", below).

```solidity
pragma solidity ^0.4.20;

import "./ERC165.sol";

/// @title Required part of ERC-721 Distinguishable Assets Registry
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0xb3a99827
interface ERC721 /* is ERC165 */ {
    /// @dev This emits when ownership of any asset changes by any mechanism.
    ///  This event emits when assets are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of assets
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that assetis implicitly reset
    ///  to the zero address.
    event Transfer(address indexed _from, address indexed _to, uint256 _assetId);

    /// @dev This emits when the approved address for an asset is changed or
    ///  reaffirmed. The zero address indicates there is no approved address for
    ///  that asset. When a Transfer event emits, this also indicates the
    ///  approved address is reset to none.
    event Approval(address indexed _owner, address indexed _approved, uint256 _assetId);

    /// @dev This emits when a third party ("operator") is enabled or disable for
    ///  an owner. The operator may manage all assets of the owner.
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    /// @notice Count all assets assigned to an owner
    /// @dev Assets assigned to zero address are considered invalid, and this
    ///  function throws for queries about the zero address.
    /// @param _owner An address for whom to query the balance
    /// @return The number of assets owned by `_owner`, possibly zero
    function balanceOf(address _owner) external view returns (uint256 _balance);

    /// @notice Find the owner of an asset
    /// @param _assetId The identifier for an asset we are inspecting
    /// @dev Assets assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @return The address of the owner of the asset
    function ownerOf(uint256 _assetId) external view returns (address _owner);

    /// @notice Transfers the ownership of an asset -- warning the caller is
    ///  responsible to confirm that the sender is capable of receiving assets
    ///  otherwise the asset may become inaccessible!
    /// @dev Throws unless `msg.sender` is the current asset owner, an operator
    ///  of the current asset owner, or the approved address of the asset.
    ///  Throws if `_to` currently owns the asset.
    /// @param _to The new owner for the asset
    /// @param _assetId The asset to transfer
    function transfer(address _to, uint256 _assetId) external payable;

    /// @notice Transfers the ownership of a given asset from one address to
    ///  another address -- warning the caller is responsible to confirm that
    ///  the sender is capable of receiving assets otherwise the asset may become 
    ///  inaccessible!
    /// @dev Throws unless `msg.sender` is the current asset owner, an operator
    ///  of the current asset owner, or the approved address of the asset.
    ///  Throws if `_to` currently owns the asset. Throws if the asset is not 
    ///  currently owned by _from.
    /// @param _from The current owner for the asset
    /// @param _to The new owner for the asset
    /// @param _assetId The asset to transfer
    function transferFrom(address _from, address _to, uint256 _assetId) external payable;

    /// @notice Set or reaffirm the authorized address for as asset
    /// @dev The zero address indicates there is no authorized address.
    /// @dev Throws unless `msg.sender` is the current asset owner, or an
    ///  operator of the current asset owner.
    /// @param _approved The new authorized address
    /// @param _assetId The asset to approve
    function approve(address _approved, uint256 _assetId) external payable;

    /// @notice Enable or disable approval for a third party ("operator") to manage
    ///  all your asset.
    /// @dev Emits the ApprovalForAll event
    /// @param _operator Address to add to the set of authorized operators.
    /// @param _approved True to appove an operators, false to revoke approval
    function setApprovalForAll(address _operateor, boolean _approved) payable;

    // CONFORMANCE TO ERC-165 //////////////////////////////////////////////////

    /// @notice Query if this implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
```

The **metadata extension** is OPTIONAL for ERC-721 implementations (see "caveats", below). This allows your contract to be interrogated for its name and for details about the assets.

```solidity
/// @title Optional metadata extension to ERC-721 Distinguishable Assets Registry
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0x2a786f11
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of assets in this contract
    function name() external pure returns (string _name);

    /// @notice An abbreviated name for assets in this contract
    function symbol() external pure returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_assetId` is not a valid asset. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function assetURI(uint256 _assetId) external view returns (string _assetURI);
}
```

This is the "ERC721 Metadata JSON Schema" referenced above. Learn more about [JSON schemas](http://json-schema.org/).

```json
{
    "title": "Asset Metadata",
    "type": "object",
    "properties": {
        "name": {
            "type": "string",
            "description": "Identifies the asset to which the DAR grants ownership",
        },
        "description": {
            "type": "string",
            "description": "Describes the asset to which the DAR grants ownership",
        },
        "image": {
            "type": "string",
            "description": "A URI pointing to a resource with mime type image/* representing the asset to which the DAR grants ownership. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.",
        }
    }
}
```

The **enumeration extension** is OPTIONAL for ERC-721 implementations (see "caveats", below). This allows your contract to publish the the full list of assets and make them discoverable.

```solidity
/// @title Optional enumeration extension to ERC-721 Distinguishable Assets Registry
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0x5576ab6a
interface ERC721Enumerable /* is ERC721 */ {
    /// @notice Count assets tracked by this contract
    /// @return A count of valid assets tracked by this contract, where each one of
    ///  them has an assigned and queryable owner not equal to the zero address
    function totalSupply() external view returns (uint256 _count);

    /// @notice Enumerate active assets
    /// @dev Throws if `_index` >= `totalSupply()`.
    /// @param _index A counter less than `totalSupply()`
    /// @return The identifier for the `_index`th asset, (sort order not
    ///  specified)
    function assetByIndex(uint256 _index) external view returns (uint256 _assetId);

    /// @notice Count of owners which own at least one asset
    /// @return A count of the number of owners which own assets
    function countOfOwners() external view returns (uint256 _count);

    /// @notice Enumerate owners
    /// @dev Throws if `_index` >= `countOfOwners()`
    /// @param _index A counter less than `countOfOwners()`
    /// @return The address of the `_index`th owner (sort order not specified)
    function ownerByIndex(uint256 _index) external view returns (address _owner);

    /// @notice Count assets of an owner
    /// @param _owner The address to check
    /// @return The number of valid assets owned by this owner
    function countOfAssetsByOwner(address _owner) external view returns (uint256 _count);

    /// @notice Enumerate assets assigned to an owner
    /// @dev Throws if `_index` >= `countOfAssetsByOwner(_owner)` or if
    ///  `_owner` is the zero address, representing invalid assets.
    /// @param _owner An address where we are interested in assets owned by them
    /// @param _index A counter less than `countOfAssetsByOwner(_owner)`
    /// @return The identifier for the `_index`th asset assigned to `_owner`,
    ///   (sort order not specified)
    function assetOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _assetId);
}
```

### Caveats

The 0.4.20 Solidity interface grammar is not expressive enough to document the ERC-721 specification. A contract which complies with ERC-721 MUST also abide by the following:

- [Solidity issue #3412](https://github.com/ethereum/solidity/issues/3412): The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: `payable`, implicit nonpayable, `view`, and `pure`. Your implementation must meet the mutability guarantee in this interface or you may meet a stronger guarantee. For example, a `payable` function in this interface may be implemented as nonpayble (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.20 is that you can edit this interface to add stricter mutability before inheriting from your contract.
- [Solidity issue #3419](https://github.com/ethereum/solidity/issues/3419): A contract that implements `ERC721Metadata` or `ERC721Enumerable` SHALL also implement `ERC721`. ERC-721 implements the requirements of interface [ERC-165](https://github.com/ethereum/EIPs/pull/881).
- [Solidity issue #2330](https://github.com/ethereum/solidity/issues/2330): If a function is shown in this specification as `external` then a contract will be compliant if it uses `public` visibility.
- Solidity issues [#3494](https://github.com/ethereum/solidity/issues/3494), [#3544](https://github.com/ethereum/solidity/issues/3544): Use of `this.*.selector` is marked as a warning by Solidity, a future version of Solidity will not mark this as an error.

*If a newer version of Solidity allows the caveats to be expressed in code, then this EIP MAY be updated and the caveats removed, such will be equivalent to the original specification.*

## Rationale

There are many proposed uses of Ethereum smart contracts that depend on tracking distinguishable assets. Examples of existing or planned NFTs are LAND in [Decentraland](https://decentraland.org/), the eponymous punks in [CryptoPunks](https://www.larvalabs.com/cryptopunks), and in-game items using systems like [Dmarket](https://www.dmarket.io/) or [EnjinCoin](https://enjincoin.io/). Future uses include tracking real-world assets, like real-estate (as envisioned by companies like [Ubitquity](https://www.ubitquity.io/) or [Propy](https://tokensale.propy.com/)). It is critical in each of these cases that these items are not "lumped together" as numbers in a ledger, but instead, each asset must have its ownership individually and atomically tracked. Regardless of the nature of these assets, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional asset management and sales platforms.

**"Asset" word choice**

We chose specifically to avoid the word "token" because it has a well known, and different, meaning in the Ethereum ecosystem, specifically ERC-20 tokens.

The word "asset" well describes all the use cases we envisioned above.

*Alternatives considered: non-fungible token, title, token, asset, equity, ticket, deed*

**Asset identifiers**

The basis of this standard is that every asset is identified by a unique 256-bit unsigned integer within its DAR. This ID number SHALL NOT change for the life of the contract. The pair `(contract address, uint265 assetId)` will then be a globally unique and fully-qualified identifier for a specific asset within the Ethereum ecosystem. While some contracts may find it convenient to start with ID 0 and simply increment by one for each new asset, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a "black box". Also note that a assets MAY become invalid (be destroyed). Please see the enumerations functions for a supported enumeration interface.

The choice of uint256 allows a wide variety of applications because UUIDs and sha3 hashes are directly convertible to uint256.

**Transfer mechanism**

ERC-721 standardizes a single transfer function `transferFrom`, one convenience function, and two mechanisms for indirection:

* The `transfer` function is equivalent to `transferFrom` except that the `_from` is calculated automatically — note that if a specific asset has an approved address then `transfer` has a race condition
  1. A and B approve operator C
  2. A transfers to B
  3. C uses `transfer` to get the asset
  4. Depending on the order of 2. and 3. getting mined, it is ambiguous whom C gets the asset from

- The owner can transfer an asset to any address (except the zero address).
- The authorized address for an asset can transfer just like the owner.
- An operator can transfer just like the owner and can assign the authorized address.

This provides a powerful set of tools for broker or auction applications to quickly use a *large* number of assets.

The `transfer` documentation only specifies conditions when the transaction MUST throw. Your implementation MAY also throw on calls `transfer`, `transfer `, `approve` and `setApproveForAll` in other situations. This allows implementations to achieve interesting results:

- **Disallow transfers if the contract is paused** — prior art, [Crypto Kitties](https://github.com/axiomzen/cryptokitties-bounty/blob/master/contracts/KittyOwnership.sol#L79)
- **Blacklist certain address from receiving assets** — prior art, [Crypto Kitties, (lines 565, 566)](https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code).
- **Require every transaction to use the the approve-transfer workflow** — require `transfer` parameter `_to` to equal `msg.sender`
- **Charge a fee to both parties of a transaction** — require payment when calling `approve` with a non-zero `_approved` if it was previously the zero address, refund payment if calling `approve` with the zero address if it was previously a non-zero address, require payment when calling `transfer`, require `transfer` parameter `_to` to equal `msg.sender`, require `transfer` parameter `_to` to be the authorized address
- **Read only DAR** — always throw from `transfer`, `approve` and `delegate`

Failed transactions will throw, a best practice identified in [ERC-233](https://github.com/ethereum/EIPs/issues/223) , [ERC-677](https://github.com/ethereum/EIPs/issues/677), [ERC-827](https://github.com/ethereum/EIPs/issues/827) and [OpenZeppelin](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/SafeERC20.sol). [ERC-20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) defined an `allowance` feature, this caused a problem when was called and then later modified to a different amount, as [disucssed on OpenZeppelin](https://github.com/OpenZeppelin/zeppelin-solidity/issues/438). In this standard, there is no allowance because every asset is unique, the quantity is none or one. Therefore we receive the benefits of ERC-20's original design without problems that have been later discovered.

Use of the `transfer` function where the caller is the owner of the asset is controversial as discussed in [ERC-233](https://github.com/ethereum/EIPs/issues/223) and [ERC-677](https://github.com/ethereum/EIPs/issues/677). But we take the position that misuse of the `transfer` function is an implementation mistake not a standards mistake.

Creating of new assets and destruction of assets is not included in the specification. Your contract may implement these by other means. Please see the `event` documentation for your responsibilities when creating or destroying assets.

*Alternatives considered: only allow two-step ERC-20 style transaction, require that `transfer` never throw, require all functions to return a boolean indicating the success of the operation.*

**ERC-165 interface**

This specification includes a function `supportsInterface` which is standardized in [ERC-165](https://github.com/ethereum/EIPs/pull/881). So any contract MAY query your contract to see if it complies with ERC-721 and the extensions.

A future EIP may create a global registry of interfaces for contracts. We strongly support such an EIP and it would allow your contract to to implement ERC721Enumerable, ERC721Metadata, or other interfaces by delegating to a separate contract.

**Gas and complexity** (regarding the enumeration extension)

This specification contemplates implementations that manage a few and *arbitrarily large* numbers of assets. If your application is able to grow then [avoid using for/while loops in your code](https://github.com/axiomzen/cryptokitties-bounty/issues/4). These indicate your contract may be unable to scale and gas costs will rise over time without bound.

[We have deployed](https://github.com/fulldecent/erc721-example) a contract to test net which instantiates and tracks 340282366920938463463374607431768211456 different assets (2^128). That's enough to assign every IPV6 address to an Ethereum account owner, or to track ownership of nanobots a few micron in size and in aggregate totalling half the size of Earth. And you can query it from the blockchain. And every function takes less gas than [querying the ENS](https://ens.domains/).

This illustration makes clear: the Distinguishable Assets Registry standard scales.

*Alternatives considered: remove the asset enumeration function if it requries a for-loop, return a Soldity array type from enumeration functions.*

**Privacy**

Wallets/brokers/auctioneers identified in the motivation section have a strong need to identify which assets an owner owns.

It may be interesting to consider a use case where assets are not enumerable or assets are not enumerable by owner, such as a private registry of property ownership, or a partially-private registry. However, privacy cannot be attained because an attacker can simply (!) call `ownerOf` for every possible `assetId`.

**Metadata choices** (metadata extension)

We have required `name` and `symbol` functions in the metadata extension. Every token EIP and draft we have reviewed ([ERC-20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md), [ERC-233](https://github.com/ethereum/EIPs/issues/223) , [ERC-677](https://github.com/ethereum/EIPs/issues/677), [ERC-827](https://github.com/ethereum/EIPs/issues/827)) included these functions. Assets **are not** tokens, but let's adopt existing conventions when it makes sense!

We remind implementation authors that the empty string is a valid response to `name` and `symbol` if you protest to the usage of this mechanism. We also remind everyone that the official contract for tracking 0xProject tokens (`ZRX`) is [0xe41d2489571d322189246dafa5ebde1f4699f498](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498). Another contract that advertises a name of `0xProject` and symbol `ZRX` is not the well-known (canonical) contract.

How a client may determine which DARs are well-known is outside the scope of this standard.

A mechanism is provided to associate assets with URIs. We expect that many implementations will take advantage of this to provide metadata for each asset. The image size recommendation is taken from Instagram, they probably know much about image usability. The URI MAY be mutable (i.e. it changes from time to time). We considered a asset representing ownership of a real-world asset, in this case metadata about such an asset may naturally change.

Metadata is returned as a string value. Currently this is only usable as calling from `web3`, not from other contracts. This is acceptable because we have not considered a use case where an on-blockchain application would query such information.

*Alternatives considered: put all metadata for each asset on the blockchain (too expensive), use URL templates to query metadata parts (URL templates do not work with all URL schemes, especially P2P URLs), [multiaddr network address](https://github.com/multiformats/multiaddr) (not mature enough)*

**Community consensus**

A significant amount of discussion occurred on [the original ERC-721](ERC-721 issue), additionally we held a live meeting [on Gitter](https://gitter.im/ethereum/ERCs?at=5a62259b5ade18be3998eec4) that had good representation and [was](https://www.reddit.com/r/ethereum/comments/7r2ena/friday_119_live_discussion_on_erc_nonfungible/) [well](https://gitter.im/ethereum/EIPs?at=5a5f823fb48e8c3566f0a5e7) [advertised](https://github.com/ethereum/eips/issues/721#issuecomment-358369377) in relevant communities. Thank you  to the participants:

- [@ImAllInNow](https://github.com/imallinnow) Rob from DEC Gaming / Presenting Michigan Ethereum Meetup Feb 7
- [@Arachnid](https://github.com/arachnid) Nick Johnson
- [@jadhavajay](https://github.com/jadhavajay) Ajay Jadhav from AyanWorks
- [@superphly](https://github.com/superphly) Cody Marx Bailey - XRAM Capital / Sharing at hackathon Jan 20 / UN Future of Finance Hackathon.

A second event was held at ETHDenver 2018 to discuss distinguishable asset standards (notes to be published).

We have been very inclusive in this process and invite anyone with questions or contributions into our discussion. However, this standard is written only to support the identified use cases which are listed herein. 

## Backwards Compatibility

We have adopted `balanceOf`, `totalSupply`, `name` and `symbol` semantics from the [ERC-20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md) specification. An implementation may also include a function `decimals` that returns `uint8 0` if its intention is to be more compatible with ERC-20 while supporting this standard. However, we find it contrived to require all ERC-721 implementations to support the `decimals` function.

Example DAR implementations as of February 2018:

- [CryptoKitties](https://www.cryptokitties.co/) — Compatible with an earlier version of this standard.
- [CryptoPunks](https://www.larvalabs.com/cryptopunks) — Partially ERC-20 compatible, but not easily generalizable because it includes auction functionality directly in the contract and uses function names that explicitly refer to the assets as "punks".
- [Auctionhouse Asset Interface](https://github.com/dob/auctionhouse/blob/master/contracts/Asset.sol) — [@dob](https://github.com/dob) needed a generic interface for his Auctionhouse dapp (currently ice-boxed). His "Asset" contract is very simple, but is missing ERC-20 compatibility, `approve()` functionality, and metadata. This effort is referenced in the discussion for [EIP-173](https://github.com/ethereum/EIPs/issues/173).

Note: "Limited edition, collectible tokens" like [Curio Cards](https://mycuriocards.com/) and [Rare Pepe](https://rarepepewallet.com/) are *not* distinguishable assets. They're actually a collection of individual fungible tokens, each of which is tracked by its own smart contract with its own total supply (which may be `1` in extreme cases).

## Test Cases

**TO DO**

Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.

## Implementations

ERC721ExampleDeed, by Nastassia Sachs: https://github.com/nastassiasachs/ERC721ExampleDeed

- Implements using the Open Zeppelin project format

XXXXERC721, by William Entriken: https://github.com/fulldecent/erc721-example

- Deployed on testnet with 1 billion assets and supporting all lookups with the metadata extension. This demonstrates that scaling is NOT a problem.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
